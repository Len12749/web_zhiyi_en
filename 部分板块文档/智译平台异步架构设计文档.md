# 智译平台异步架构设计文档

## 1. 架构概述

智译平台采用基于 Server-Sent Events (SSE) 的异步架构，实现了文档处理服务的实时状态反馈和高效处理。该架构解决了长时间运行任务的用户体验问题，确保即使在处理大型文件或复杂任务时，用户也能获得实时的进度更新和状态反馈。

### 1.1 核心架构原则

- **异步处理**：所有文档处理任务都在后台异步执行，不阻塞用户界面
- **实时反馈**：通过 SSE 向前端推送实时状态更新
- **状态持久化**：任务状态保存在数据库中，确保系统重启或连接断开后仍能恢复
- **连接管理**：SSE 连接是临时的技术实现，仅在内存中管理，不持久化到数据库
- **任务驱动**：所有文件处理操作都创建 processing_tasks 记录并通过 SSE 推送状态

## 2. 技术实现

### 2.1 SSE 连接管理

智译平台使用两种 SSE 连接管理器：

1. **任务 SSE 管理器**：处理特定任务的状态更新
2. **通知 SSE 管理器**：处理全局通知推送

这两个管理器都采用内存中的 Map 结构来存储连接信息，确保高效的消息推送和连接管理。

```typescript
// 文件: lib/sse/connection-manager.ts
// 任务状态SSE连接管理器
class TaskSSEManager {
  private connections = new Map<string, {
    userId: string;
    taskId: number;
    controller: ReadableStreamDefaultController<Uint8Array>;
    connectionId: string;
  }>();
  
  // 添加连接
  addConnection(connectionId: string, userId: string, taskId: number, controller: ReadableStreamDefaultController<Uint8Array>) {
    this.connections.set(connectionId, { userId, taskId, controller, connectionId });
  }
  
  // 推送状态更新给特定任务
  pushToTask(taskId: number, statusUpdate: { type: string; data: any }) {
    const taskConnections = Array.from(this.connections.values())
      .filter(conn => conn.taskId === taskId);
      
    // 推送消息到所有相关连接
    // ...
  }
  
  // 其他方法...
}

// 导出单例实例
export const sseConnectionManager = new TaskSSEManager();
```

### 2.2 任务处理流程

智译平台的任务处理流程由以下核心文件实现：

- **actions/tasks/task-actions.ts**: 任务管理的核心文件，包含任务创建、状态更新、完成和失败处理等功能
- **app/api/tasks/create/route.ts**: 任务创建API端点，处理前端的任务创建请求
- **lib/processing/task-processor.ts**: 任务处理器实现，负责执行任务处理逻辑
- **app/api/sse/tasks/[taskId]/route.ts**: 任务SSE连接端点，建立实时状态推送通道
- **app/api/tasks/webhook/route.ts**: 外部服务回调处理，接收异步任务完成通知
- **lib/sse/connection-manager.ts**: SSE连接管理器，管理前端连接和消息推送

流程如下：

1. **任务创建**：
   - 前端上传文件并提交处理请求
   - 后端验证请求并创建任务记录
   - 返回任务 ID 和 SSE URL 给前端

2. **SSE 连接建立**：
   - 前端使用返回的 SSE URL 建立 EventSource 连接
   - 后端注册连接并发送初始状态

3. **异步任务处理**：
   - 后端启动异步处理任务
   - 处理过程中定期更新任务状态并通过 SSE 推送进度
   - 任务完成后推送完成状态和结果下载链接

4. **断线处理**：
   - 任务处理独立于 SSE 连接，即使连接断开也继续处理
   - 用户可以随时重新连接并获取最新状态
   - 任务状态持久化在数据库中，确保可恢复性

## 3. 关键技术组件

### 3.1 任务创建与管理的核心文件

智译平台中涉及任务创建和管理的主要代码文件如下：

1. **actions/tasks/task-actions.ts**
   - 任务管理的核心文件，包含所有任务相关的服务器端操作
   - 主要功能：
     - `createProcessingTask`: 创建新任务，计算并扣除积分
     - `getUserTasks`: 获取用户的任务列表
     - `getTaskById`: 根据ID获取任务详情
     - `updateTaskStatus`: 更新任务状态和进度
     - `completeTask`: 完成任务并处理结果
     - `failTask`: 处理任务失败逻辑，返还积分
     - `deleteTask`: 删除任务记录

2. **app/api/tasks/create/route.ts**
   - 处理前端的任务创建请求
   - 主要功能：
     - 验证用户权限和请求参数
     - 调用`createProcessingTask`创建任务
     - 异步启动任务处理
     - 返回任务ID和SSE连接URL给前端

3. **lib/processing/task-processor.ts**
   - 负责实际执行任务处理逻辑的核心类
   - 主要功能：
     - `processTask`: 处理上传的文件任务
     - `processTaskFromPath`: 从文件路径处理任务
     - `completeExternalTask`: 完成外部异步任务
     - `downloadResult`: 下载并保存处理结果
     - `saveResultFile`: 将结果保存到文件系统

4. **app/api/tasks/webhook/route.ts**
   - 处理外部服务的异步任务完成回调
   - 主要功能：
     - 接收外部任务状态更新
     - 根据外部任务ID查找内部任务
     - 处理任务完成或失败逻辑

### 3.2 SSE 端点实现

```typescript
// 文件: app/api/sse/tasks/[taskId]/route.ts
// 任务SSE端点实现
export async function GET(request: NextRequest, { params }: { params: { taskId: string } }) {
  try {
    const { userId } = auth();
    
    if (!userId) {
      return NextResponse.json(
        { success: false, message: "用户未认证" },
        { status: 401 }
      );
    }

    const taskId = parseInt(params.taskId);
    
    // 验证任务权限并获取当前状态
    const taskResult = await getTaskById(taskId);
    if (!taskResult.success || !taskResult.task) {
      return NextResponse.json(
        { success: false, message: "任务不存在或无权限访问" },
        { status: 404 }
      );
    }

    // 创建SSE流
    const stream = new ReadableStream({
      async start(controller) {
        const connectionId = generateRandomString(16);
        
        // 注册SSE连接
        sseConnectionManager.addConnection(connectionId, userId, taskId, controller);
        
        // 发送初始状态
        const initialMessage = {
          type: "status_update",
          data: {
            taskId: taskId,
            status: taskResult.task.taskStatus,
            progress: taskResult.task.progressPercent || 0,
            message: taskResult.task.statusMessage || '',
          }
        };
        
        // 设置连接关闭处理
        request.signal.addEventListener('abort', () => {
          sseConnectionManager.removeConnection(connectionId);
        });
      },
    });
    
    return new NextResponse(stream, {
      headers: {
        'Content-Type': 'text/event-stream',
        'Cache-Control': 'no-cache',
        'Connection': 'keep-alive',
      },
    });
  } catch (error) {
    console.error("任务SSE连接错误:", error);
    return NextResponse.json(
      { success: false, message: "建立任务SSE连接失败" },
      { status: 500 }
    );
  }
}
```

### 3.2 任务处理器

```typescript
// 文件: lib/processing/task-processor.ts
// 任务处理器核心类
export class TaskProcessor {
  private taskId: number;
  private userId: string;
  private taskType: TaskType;
  private externalTaskId?: string;

  constructor(taskId: number, userId: string, taskType: TaskType, externalTaskId?: string) {
    this.taskId = taskId;
    this.userId = userId;
    this.taskType = taskType;
    this.externalTaskId = externalTaskId;
  }

  // 推送SSE状态更新
  private async pushStatusUpdate(status: string, progress: number, message?: string) {
    // 更新数据库状态
    await updateTaskStatus(this.taskId, status, progress, message);
    
    // 推送SSE消息
    sseConnectionManager.pushToTask(this.taskId, {
      type: 'status_update',
      data: { status, progress, message }
    });
  }
  
  // 处理任务
  async processTaskFromPath<T extends TaskType>(filePath: string, params: TaskParams[T]): Promise<void> {
    try {
      console.log(`🚀 [${this.taskId}] 开始处理任务，类型: ${this.taskType}`);
      
      // 更新状态为处理中
      await this.pushStatusUpdate('processing', 0, '开始处理...');
      
      // 从存储路径读取文件
      const { readFile } = await import('fs/promises');
      const { join } = await import('path');
      
      // 构建完整文件路径
      const dataStoragePath = process.env.DATA_STORAGE_PATH || './data';
      const fullPath = join(dataStoragePath, filePath, 'original');
      
      // 处理任务逻辑
      // ...
      
      // 定期更新进度
      await this.pushStatusUpdate('processing', 50, '处理中...');
      
      // 完成处理
      await this.pushStatusUpdate('completed', 100, '处理完成');
    } catch (error) {
      // 处理失败
      console.error(`❌ [${this.taskId}] 从路径处理任务失败:`, error);
      await this.pushStatusUpdate('failed', 0, error.message);
    }
  }
}
```

### 3.3 前端实现

```typescript
// 文件: app/[功能模块]/_components/task-processor.tsx
// 前端SSE连接实现
import { useEffect, useState } from 'react';

export function useTaskStatus(taskId: number) {
  const [status, setStatus] = useState('pending');
  const [progress, setProgress] = useState(0);
  const [message, setMessage] = useState('');
  const [error, setError] = useState<string | null>(null);
  
  useEffect(() => {
    if (!taskId) return;
    
    // 构建SSE URL
    const sseUrl = `/api/sse/tasks/${taskId}`;
    const eventSource = new EventSource(sseUrl);
    
    eventSource.onopen = () => {
      console.log('✅ SSE连接已建立');
    };
    
    eventSource.onmessage = (event) => {
      try {
        const data = JSON.parse(event.data);
        
        if (data.type === 'status_update') {
          setStatus(data.data.status);
          setProgress(data.data.progress || 0);
          setMessage(data.data.message || '');
          
          if (data.data.status === 'failed') {
            setError(data.data.message || '处理失败');
          }
        }
      } catch (error) {
        console.error('SSE消息解析失败:', error);
      }
    };
    
    eventSource.onerror = () => {
      console.error('SSE连接错误');
      eventSource.close();
    };
    
    // 清理函数
    return () => {
      eventSource.close();
    };
  }, [taskId]);
  
  return { status, progress, message, error };
}
```

## 4. 异步架构优势

### 4.1 用户体验提升

- **实时反馈**：用户无需刷新页面即可获取任务进度和状态
- **断点续连**：即使用户暂时离开页面，任务仍在后台处理，返回后可继续查看进度
- **多任务并行**：用户可以同时提交多个任务，系统能并行处理并推送各自的状态

### 4.2 系统效率提升

- **资源优化**：长时间任务不占用前端资源，避免浏览器超时
- **负载分散**：任务处理与用户界面分离，系统负载更均衡
- **可扩展性**：处理逻辑与前端解耦，便于横向扩展处理能力

### 4.3 可靠性提升

- **状态持久化**：任务状态保存在数据库中，系统重启不影响任务恢复
- **错误隔离**：单个任务失败不影响其他任务或用户体验
- **重试机制**：支持失败任务的自动或手动重试

## 5. 任务创建与管理的完整流程

智译平台的任务创建与管理流程如下：

1. **任务创建** (文件: app/api/tasks/create/route.ts)
   - 前端调用 `/api/tasks/create` API
   - `app/api/tasks/create/route.ts` 接收请求并验证参数
   - 调用 `actions/tasks/task-actions.ts` 中的 `createProcessingTask` 创建任务记录
   - 异步启动 `processTaskAsync` 处理任务
   - 返回任务ID和SSE URL给前端

2. **任务处理** (文件: lib/processing/task-processor.ts)
   - `TaskProcessor` 类处理任务
   - 根据任务类型调用相应的处理逻辑
   - 通过 `pushStatusUpdate` 方法更新任务状态和进度
   - 对于异步任务，等待外部服务通过webhook回调

3. **状态监控** (文件: app/api/sse/tasks/[taskId]/route.ts)
   - 前端通过 `/api/sse/tasks/[taskId]` 建立SSE连接
   - 验证权限并建立连接
   - `lib/sse/connection-manager.ts` 管理连接并推送状态更新
   - 任务状态变化时实时推送到前端

4. **任务完成**
   - 同步任务：直接处理结果并更新状态
   - 异步任务：通过 `app/api/tasks/webhook/route.ts` 接收外部服务回调
   - 调用 `actions/tasks/task-actions.ts` 中的 `completeTask` 完成任务
   - 通过SSE推送完成状态到前端

5. **错误处理** (文件: actions/tasks/task-actions.ts)
   - 任务失败时调用 `failTask` 方法
   - 返还预扣的积分
   - 记录错误信息并通过SSE推送到前端

## 6. 架构挑战与解决方案

### 6.1 连接管理

**挑战**：大量并发连接可能导致内存占用过高
**解决方案**：
- 实现连接超时机制，自动清理长时间无活动的连接
- 定期发送心跳消息保持连接活跃
- 实现连接数限制和负载均衡策略

### 6.2 状态一致性

**挑战**：确保数据库状态与推送给用户的状态一致
**解决方案**：
- 先更新数据库再推送消息
- 实现事务机制确保状态更新的原子性
- 定期同步机制修复可能的不一致状态

### 6.3 错误处理

**挑战**：异步任务的错误难以追踪和处理
**解决方案**：
- 完善的日志记录系统
- 错误状态持久化到数据库
- 通过 SSE 实时推送错误信息给用户
- 实现监控告警机制
